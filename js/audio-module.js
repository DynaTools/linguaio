// audio.js - M√≥dulo para funcionalidades de √°udio e shadowing

/**
 * Inicializa o sistema de √°udio e shadowing
 */
function initAudioSystem() {
    const playBtn = document.getElementById('play-btn');
    const recordBtn = document.getElementById('record-btn');
    const speedSelect = document.getElementById('speed-select');
    const targetText = document.getElementById('target-text');
    const targetLanguage = document.getElementById('target-language');
    
    // Estado do sistema de √°udio
    let isRecording = false;
    let audioContext = null;
    let mediaRecorder = null;
    let audioStream = null;
    let audioChunks = [];
    let recordedAudio = null;
    let synth = window.speechSynthesis;
    
    // Inicializar sintetizador de voz
    let utterance = new SpeechSynthesisUtterance();
    
    // Bot√£o de reprodu√ß√£o
    playBtn.addEventListener('click', () => {
        if (synth.speaking) {
            synth.cancel();
            playBtn.textContent = '‚ñ∂Ô∏è Reproduzir';
            return;
        }
        
        if (targetText.value) {
            // Configurar enunciado
            utterance.text = targetText.value;
            
            // Definir idioma baseado na sele√ß√£o
            const langMap = {
                'en': 'en-US',
                'pt': 'pt-BR',
                'es': 'es-ES',
                'fr': 'fr-FR',
                'de': 'de-DE',
                'it': 'it-IT'
            };
            
            utterance.lang = langMap[targetLanguage.value] || 'en-US';
            
            // Definir velocidade baseada na sele√ß√£o
            const speedValue = speedSelect.value;
            if (speedValue.includes('Lenta')) {
                utterance.rate = 0.7;
            } else if (speedValue.includes('Muito Lenta')) {
                utterance.rate = 0.5;
            } else {
                utterance.rate = 1.0;
            }
            
            // Animar a forma de onda enquanto fala
            animateWaveform('model-wave');
            
            // Alterar texto do bot√£o
            playBtn.textContent = '‚è∏Ô∏è Pausar';
            
            // Reproduzir √°udio
            synth.speak(utterance);
            
            // Restaurar bot√£o quando terminar
            utterance.onend = () => {
                playBtn.textContent = '‚ñ∂Ô∏è Reproduzir';
                stopWaveformAnimation('model-wave');
            };
        }
    });
    
    // Bot√£o de grava√ß√£o
    recordBtn.addEventListener('click', async () => {
        // Alternar estado de grava√ß√£o
        isRecording = !isRecording;
        
        if (isRecording) {
            // Iniciar grava√ß√£o
            try {
                // Solicitar permiss√£o para acessar o microfone
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Configurar o gravador
                mediaRecorder = new MediaRecorder(audioStream);
                audioChunks = [];
                
                // Coletar dados de √°udio
                mediaRecorder.addEventListener('dataavailable', event => {
                    audioChunks.push(event.data);
                });
                
                // Quando a grava√ß√£o terminar
                mediaRecorder.addEventListener('stop', () => {
                    // Criar blob de √°udio
                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                    
                    // Cria URL para o √°udio
                    recordedAudio = URL.createObjectURL(audioBlob);
                    
                    // Analisar a precis√£o (simula√ß√£o)
                    analyzeAudioAccuracy();
                });
                
                // Iniciar grava√ß√£o
                mediaRecorder.start();
                
                // Animar a forma de onda do usu√°rio
                animateWaveform('user-wave');
                
                // Alterar apar√™ncia do bot√£o
                recordBtn.style.backgroundColor = '#f44336';
                recordBtn.textContent = '‚èπÔ∏è';
                
            } catch (error) {
                console.error('Erro ao acessar o microfone:', error);
                alert('N√£o foi poss√≠vel acessar o microfone. Verifique as permiss√µes do navegador.');
                
                // Resetar estado
                isRecording = false;
                recordBtn.style.backgroundColor = 'var(--error-color)';
                recordBtn.textContent = 'üéôÔ∏è';
            }
        } else {
            // Parar grava√ß√£o
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                
                // Parar stream do microfone
                if (audioStream) {
                    audioStream.getTracks().forEach(track => track.stop());
                }
                
                // Parar anima√ß√£o
                stopWaveformAnimation('user-wave');
                
                // Alterar apar√™ncia do bot√£o temporariamente
                recordBtn.style.backgroundColor = '#4caf50';
                recordBtn.textContent = '‚úì';
                
                // Restaurar bot√£o ap√≥s um momento
                setTimeout(() => {
                    recordBtn.style.backgroundColor = 'var(--error-color)';
                    recordBtn.textContent = 'üéôÔ∏è';
                }, 2000);
            }
        }
    });
    
    // Analisar precis√£o do √°udio (simula√ß√£o)
    function analyzeAudioAccuracy() {
        // Em uma implementa√ß√£o real, usar√≠amos reconhecimento de voz
        // e compara√ß√£o com o texto traduzido
        
        // Simular uma precis√£o aleat√≥ria entre 65% e 95%
        const accuracy = Math.floor(Math.random() * 30) + 65;
        
        // Atualizar o medidor de precis√£o
        const accuracyFill = document.querySelector('.accuracy-fill');
        accuracyFill.style.width = `${accuracy}%`;
        
        // Adicionar cor baseada na precis√£o
        if (accuracy >= 85) {
            accuracyFill.style.backgroundColor = 'var(--success-color)';
        } else if (accuracy >= 70) {
            accuracyFill.style.backgroundColor = 'var(--warning-color)';
        } else {
            accuracyFill.style.backgroundColor = 'var(--error-color)';
        }
    }
    
    // Anima√ß√£o da forma de onda
    function animateWaveform(waveClass) {
        const waveform = document.querySelector(`.${waveClass}`);
        const waveBars = waveform.querySelectorAll('.wave-bar');
        
        // ID da anima√ß√£o para controle
        waveform.animationId = setInterval(() => {
            waveBars.forEach(bar => {
                // Gerar altura aleat√≥ria
                const height = Math.floor(Math.random() * 70) + 10;
                bar.style.height = `${height}%`;
            });
        }, 150);
    }
    
    // Parar anima√ß√£o da forma de onda
    function stopWaveformAnimation(waveClass) {
        const waveform = document.querySelector(`.${waveClass}`);
        
        if (waveform.animationId) {
            clearInterval(waveform.animationId);
            waveform.animationId = null;
        }
    }
    
    // Verificar se o navegador suporta as APIs necess√°rias
    function checkBrowserSupport() {
        // Verificar suporte para Speech Synthesis
        if (!('speechSynthesis' in window)) {
            playBtn.disabled = true;
            alert('Seu navegador n√£o suporta s√≠ntese de voz. Tente usar o Chrome ou Edge.');
        }
        
        // Verificar suporte para Media Devices API
        if (!('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices)) {
            recordBtn.disabled = true;
            alert('Seu navegador n√£o suporta acesso ao microfone. Tente usar o Chrome ou Edge.');
        }
    }
    
    // Verificar suporte do navegador ao inicializar
    checkBrowserSupport();
}
